<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>快排 - 近来学点SIMD如何？</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="foreword.html"><strong aria-hidden="true">1.</strong> 近来学点SIMD如何？</a></li><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">2.</strong> SIMD简单介绍</a></li><li class="chapter-item expanded "><a href="x86simd.html"><strong aria-hidden="true">3.</strong> x86 SIMD基础</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="instruction.html"><strong aria-hidden="true">3.1.</strong> 指令集</a></li><li class="chapter-item expanded "><a href="intrinsic.html"><strong aria-hidden="true">3.2.</strong> SIMD intrinsic</a></li></ol></li><li class="chapter-item expanded "><a href="algorithm.html"><strong aria-hidden="true">4.</strong> 算法</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="matmul.html"><strong aria-hidden="true">4.1.</strong> 矩阵乘法</a></li><li class="chapter-item expanded "><a href="parse_num.html"><strong aria-hidden="true">4.2.</strong> parse number</a></li><li class="chapter-item expanded "><a href="qsort.html" class="active"><strong aria-hidden="true">4.3.</strong> 快排</a></li></ol></li><li class="chapter-item expanded "><a href="conclusion.html"><strong aria-hidden="true">5.</strong> 未来畅想</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">近来学点SIMD如何？</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="快排"><a class="header" href="#快排">快排</a></h1>
<p>SIMD还有一个让我觉得意想不到的能力是，可以用来做排序。<a href="https://arxiv.org/pdf/1704.08579">这篇论文</a>提出了一种基于AVX512指令的快排优化算法。</p>
<p>该论文提出快排有两个开销最大的部分：</p>
<ol>
<li>partition部分，也就是把比基准小的放基准左边，把基准大的放基准右边——这是快排N*lg(N)前面那个一次的N的来源。</li>
<li>短数组排序——当快排划分到小的区间进行排序的时候。</li>
</ol>
<h2 id="partition"><a class="header" href="#partition">partition</a></h2>
<p>论文提出了新的partition算法，它利用了SIMD批量读出写入、批量比较的能力，尤其是AVX512中的<code>cmp_mask</code>和<code>compressstore</code>运算。这里就详细介绍一下这个算法。</p>
<ol>
<li>
<p>首先是，<code>simd_partition</code>接口，选取<code>arr</code>最后一个元素为基准，函数将<code>arr</code>中小于等于基准的元素放在左边，大于基准的元素放在右边，而函数的返回值是右边的第一个元素的下标（也就是第一个比基准大的元素）。要求数组的长度大于等于两倍的向量长度。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn simd_partition(arr: &amp;mut [i32]) -&gt; usize;
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>这个算法主要维护几个下标：</p>
<ul>
<li><code>left</code>：从0开始，递增步长一般为向量的长度，直到<code>left == right</code>，用于批量读入数组的值。</li>
<li><code>right</code>：从len - 1开始，递减步长一般为向量的长度，直到<code>left == right</code>，用于批量读入数组的值。</li>
<li><code>left_w</code>：从0开始递增，直到<code>left_w == right_w</code>，用于写入从<code>left</code>或者<code>right</code>中读到小于等于基准的值，每次递增保证<code>left_w</code>左边的值小于等于基准。</li>
<li><code>right_w</code>：从len - 1开始递减，直到<code>left_w == right_w</code>，用于写入从<code>left</code>或者<code>right</code>中读到大于基准的值，每次递增保证<code>right_w</code>右边的值大于基准。</li>
</ul>
</li>
</ol>
<p>算法的详细代码</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 向量长度，这里为 16
const S: usize = size_of::&lt;__m512i&gt;() / size_of::&lt;i32&gt;();

/// Safety
/// - arr.len() &gt; 2*S
unsafe fn simd_partition(arr: &amp;mut [i32]) -&gt; usize {
    let mut left = 0;
    let mut right = arr.len() - 1;
    unsafe {
        // 基准向量
        let pivotvec = _mm512_set1_epi32(arr[right]);

        // 1. 读出第一个向量和最后一个向量的值，并推进`left`和`right`。这两个向量做特殊处理。
        let left_val = _mm512_loadu_epi32(arr.as_ptr().offset(left as isize));
        let mut left_w = left;
        left += S;

        let mut right_w = right;
        right -= S;
        let right_val = _mm512_loadu_epi32(arr.as_ptr().offset(right as isize));

        // 2. 让`left`和`right`尽可能以一个向量长度的步长向中间推进。
        while left + S &lt;= right {
            let val;
            // 从`left`或`right`中读出一个向量，并推进
            if left - left_w &lt;= right_w - right {
                val = _mm512_loadu_epi32(arr.as_ptr().offset(left as isize));
                left += S;
            } else {
                right -= S;
                val = _mm512_loadu_epi32(arr.as_ptr().offset(right as isize));
            }

            // 将读出的值批量与基准比较
            let mask = _mm512_cmp_epi32_mask::&lt;_MM_CMPINT_LE&gt;(val, pivotvec);

            // 小于等于基准值的个数
            let nb_low = mask.count_ones() as usize;
            // 大于等于基准值的个数
            let nb_high = S - nb_low;

            // 将小于等于基准的部分写到`left_w`中，并推进`left_w`
            _mm512_mask_compressstoreu_epi32(
                arr.as_mut_ptr().offset(left_w as isize) as *mut i32 as _,
                mask,
                val,
            );
            left_w += nb_low;

            // 将大于基准的部分写到`right_w`中，并推进`right_w`
            right_w -= nb_high;
            _mm512_mask_compressstoreu_epi32(
                arr.as_mut_ptr().offset(right_w as isize) as *mut i32 as _,
                !mask,
                val,
            );
        }

        // 3. 处理当`left`与`right`之间不足一个向量长度的情况
        {
            let remaining = right - left;
            let val = _mm512_loadu_epi32(arr.as_ptr().offset(left as isize));
            // left = right;

            let mask = _mm512_cmp_epi32_mask::&lt;_MM_CMPINT_LE&gt;(val, pivotvec);

            // 只关心`left`和`right`之间的数据
            let mask_low = mask &amp; !(0xFFFF &lt;&lt; remaining);
            let mask_high = !mask &amp; !(0xFFFF &lt;&lt; remaining);

            // 下面处理同上
            let nb_low = mask_low.count_ones() as usize;
            let nb_high = mask_high.count_ones() as usize;

            _mm512_mask_compressstoreu_epi32(
                arr.as_mut_ptr().offset(left_w as isize) as *mut i32 as _,
                mask_low,
                val,
            );
            left_w += nb_low;

            right_w -= nb_high;
            _mm512_mask_compressstoreu_epi32(
                arr.as_mut_ptr().offset(right_w as isize) as *mut i32 as _,
                mask_high,
                val,
            );
        }
        
        // 4. 再处理一开始没有用于比较的一个向量和最后一个向量（处理方法一致）
        {
            let mask = _mm512_cmp_epi32_mask::&lt;_MM_CMPINT_LE&gt;(left_val, pivotvec);

            let nb_low = mask.count_ones() as usize;
            let nb_high = S - nb_low;

            _mm512_mask_compressstoreu_epi32(
                arr.as_mut_ptr().offset(left_w as isize) as *mut i32 as _,
                mask,
                left_val,
            );
            left_w += nb_low;

            right_w -= nb_high;
            _mm512_mask_compressstoreu_epi32(
                arr.as_mut_ptr().offset(right_w as isize) as *mut i32 as _,
                !mask,
                left_val,
            );
        }
        {
            let mask = _mm512_cmp_epi32_mask::&lt;_MM_CMPINT_LE&gt;(right_val, pivotvec);

            let nb_low = mask.count_ones() as usize;
            let nb_high = S - nb_low;

            _mm512_mask_compressstoreu_epi32(
                arr.as_mut_ptr().offset(left_w as isize) as *mut i32 as _,
                mask,
                right_val,
            );
            left_w += nb_low;

            right_w -= nb_high;
            _mm512_mask_compressstoreu_epi32(
                arr.as_mut_ptr().offset(right_w as isize) as *mut i32 as _,
                !mask,
                right_val,
            );
        }
        
        // assert_eq!(left_w, right_w);
        arr.swap(left_w, arr.len() - 1);
        left_w
    }
}
<span class="boring">}</span></code></pre></pre>
<p>这里用一个实际的例子做一下演示，给定数据为<code>arr = [10, 1, 8, 3, 6, 5, 4, 7, 2, 9]</code>，向量长度为2。</p>
<pre><code class="language-text">----------------------- init --------------------------
arr = [10, 1, 8, 3, 6, 5, 4, 7, 2, 9] pivot = 9
left = 0         | right = 9
left_w = 0       | right_w = 9

----------------------- step1 --------------------------
arr = [10, 1, 8, 3, 6, 5, 4, 7, 2, 9] pivot = 9
left = 2         | right = 7
left_w = 0       | right_w = 9
left_v = [10, 1] | right_v = [7, 2] // 这里其实漏了最后一个9

----------------------- step2 --------------------------
val = [8, 3] // 从`left`读向量。都比 pivot小

arr = [[8, 3], 8, 3, 6, 5, 4, 7, 2, 9] pivot = 9 // 将`val`写入`left_w`
        ^  ^

left = 4         | right = 7
left_w = 2       | right_w = 9 // 推进`left_w`

----------------------- step2 --------------------------
val = [6, 5] // 从`left`读向量。都比 pivot小

arr = [8, 3, [6, 5], 6, 5, 4, 7, 2, 9] pivot = 9 // 将`val`写入`left_w`
              ^  ^

left = 6         | right = 7
left_w = 4       | right_w = 9 // 推进`left_w`

----------------------- step3 --------------------------
val = [4] // 读`left`和`right`之间的值，比pivot小

arr = [8, 3, 6, 5, [4], 5, 4, 7, 2, 9] pivot = 9 // 将`val`写入`left_w`
                    ^
                    
left = 7         | right = 7
left_w = 5       | right_w = 9 // 推进`left_w`


----------------------- step4 --------------------------
left_val = [10, 1] // 处理`left_val`，10比`pivot`大，1比`pivot`小

arr = [8, 3, 6, 5, 4, [1, 4], 7, [10, 9]] pivot = 9 // 将[1]写入`left_w`，将[10]写入`right_w - 1`
                       ^           ^
                       
left_w = 6       | right_w = 8 // 推进`left_w`/`right_w`

----------------------- step4 --------------------------
left_val = [7, 2] // 处理`right_val`都比pivot小

arr = [8, 3, 6, 5, 4, 1, [7, 2], 10, 9] pivot = 9 // 将[7, 2]写入`left_w`
                          ^  ^
left_w = 8       | right_w = 8 // 推进`left_w`

----------------------- step5 --------------------------
// 交换`arr[left_w]`和pivot的位置

arr = [8, 3, 6, 5, 4, 1, 7, 2, 9, 10]
                               ^ left_w = 8

</code></pre>
<p>最后结果为<code>arr = [8, 3, 6, 5, 4, 1, 7, 2, 9, 10]</code>，返回8。</p>
<h2 id="短数组排序双调排序bitonic-sort"><a class="header" href="#短数组排序双调排序bitonic-sort">短数组排序——双调排序(bitonic sort)</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Bitonic_sorter">双调排序</a>是一种并行排序的算法，在并行的情况下时间复杂度仅为 \(O\left(\log^2\left(n\right)\right) \)。比如说8个元素的双调排序的操作可以用一个图来描述：</p>
<p><img src="images/bitonic8.png" alt="bitonic" /></p>
<p>这个图从左边输入8个数，遇到连接线的时候将对应的数字进行比较/交换的操作，到右边输出的就是从上到下排好序的数字了。这里从左到右：</p>
<ol>
<li><code>(arr[0], arr[1])</code>，<code>(arr[2], arr[3])</code>，<code>(arr[4], arr[5])</code>，<code>(arr[6], arr[7])</code>进行比较交换操作</li>
<li><code>(arr[0], arr[3])</code>，<code>(arr1, arr[2])</code>，<code>(arr[3], arr[7])</code>，<code>(arr[5], arr[6])</code>进行比较和交换操作</li>
<li><code>(arr[0], arr[1])</code>，<code>(arr[2], arr[3])</code>，<code>(arr[4], arr[5])</code>，<code>(arr[6], arr[7])</code>进行比较交换操作</li>
<li><code>(arr[0], arr[7])</code>，<code>(arr[1], arr[6])</code>，<code>(arr[2], arr[5])</code>，<code>(arr[3], arr[4])</code>进行比较和交换操作</li>
<li><code>(arr[0], arr[2])</code>，<code>(arr[1], arr[3])</code>，<code>(arr[4], arr[6])</code>，<code>(arr[5], arr[7])</code>进行比较和交换操作</li>
<li><code>(arr[0], arr[1])</code>，<code>(arr[2], arr[3])</code>，<code>(arr[4], arr[5])</code>，<code>(arr[6], arr[7])</code>进行比较交换操作</li>
</ol>
<p>这里每一步的比较和交换操作可以用向量操作来完成，比如第一步可以写为：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn bitonic_sort_1v(v: __m256i) -&gt; __m256i {
    {
        // 0,1; 2,3; 4,5; 6,7交换
        let idxs = _m256_set_epi32(6, 7, 4, 5, 2, 3, 0, 1);
        let perm = _m256_permutexvar_epi32(idx, v);
        // compare
        let mins = _m256_min_epi32(v, perm);
        let maxs = _m256_max_epi32(perm, v);
        // exchange
        // 0,2,4,6位取mins, 1,3,5,7位取maxs
        v = _mm256_mask_mov_epi32(mins, 0b10101010, maxs);
        
        // example:
        // v:    [1, 4, 3, 2]
        // perm: [4, 1, 2, 3]
        // mins: [1, 1, 2, 2]
        // maxs: [4, 4, 3, 3]
        // res:  [1, 4, 2, 3]
    }
    
    // 剩下的类似...
}

 
<span class="boring">}</span></code></pre></pre>
<p>目前我的实现中，对于小于等于两个向量长度的数组使用双调排序（刚好覆盖了<code>simd_partition</code>没处理的情况），而对于不满一个或者两个向量长度的数组，会填充<code>i32::MAX</code>。（论文作者的实现则是16个向量长度以下的数组用双调排序）</p>
<h2 id="bench"><a class="header" href="#bench">bench</a></h2>
<p>处理器是11th Gen Intel(R) Core(TM) i7-1185G7 @ 3.00GHz。做了10, 100, 1000, 10000, 100000, 1000000个随机i32排序的bench。</p>
<p>SIMD加速的快排在现有的测试下规模越大的数组里优势越明显，比标准库提供的快排有3~4倍的提升</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>simd</th><th>normal</th><th>std</th></tr></thead><tbody>
<tr><td>10</td><td>30.004 ns</td><td>71.013 ns</td><td>38.443 ns</td></tr>
<tr><td>100</td><td>322.27 ns</td><td>894.56 ns</td><td>666.08 ns</td></tr>
<tr><td>1000</td><td>3.1232 µs</td><td>24.163 µs</td><td>9.1394 µs</td></tr>
<tr><td>10000</td><td>37.535 µs</td><td>537.69 µs</td><td>177.11 µs</td></tr>
<tr><td>100000</td><td>572.28 µs</td><td>6.4045 ms</td><td>2.1345 ms</td></tr>
<tr><td>1000000</td><td>7.1806 ms</td><td>76.253 ms</td><td>29.755 ms</td></tr>
</tbody></table>
</div>
<p><img src="images/qsort_lines.svg" alt="lines" /></p>
<p>不过这篇论文是基于AVX512指令设计的快排算法，通用性很一般。不过Google提出了一个<a href="https://opensource.googleblog.com/2022/06/Vectorized%20and%20performance%20portable%20Quicksort.html">新的算法</a>，跨平台，使用不同平台中提供的SIMD指令进行排序，同时也保证了效率。。（不过我没看懂）</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="parse_num.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="conclusion.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="parse_num.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="conclusion.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
